--Name : PveStarTempleModel.lua
--Author : generated by FairyGUI
--Date : 2020-7-27
--Desc :

local PveStarTempleModel = class("PveStarTempleModel", BaseModel)
local TableUtil = require "Game.Utils.TableUtil"
local isRefreshHeroList = true

function PveStarTempleModel:ctor()
    self.roundNumber = false--轮数
    self.roundTime = false--剩余时间
	self.currSelectHeroIndex=false
	
	
	
    self.layer = false--层数
    self.maxLayer = false--最大层数
    self.roundLayer = false--轮回层数
    self.auto = false
    self.battleFlag = false
    self.currQuestionIndex = false
    self.sweep = false
    self.isReset = false
    self.currEventOnlyID = false
    self.heroList = {}
    self.monsterList = {}
    self.attrList = {}
    self.taskList = {}
    self.taskHasGet = {}
    self.taskIDList = {}
    self.itemUseLimit = {}
    self.layerMaster = {}
    self.exploreShop = {}
    self.mysteryShop = {}
    self.layerReward = {}
    self.heroDataList = {}
    self.currQuestionList = {}
    self.PveStarTemple = {}
    self.eventConfigList = {}
    self.allCard = {}
    self.areaMonsterData = {}
    self.PveStarTemple.Base     = 0    --占位
    self.PveStarTemple.Drop     = 1    --掉落类型
    self.PveStarTemple.Buff     = 2    --BUFF加成
    self.PveStarTemple.Item     = 3    --道具类型
    self.PveStarTemple.Answer   = 4    --答题
    self.PveStarTemple.Npc      = 5    --npc
    self.PveStarTemple.Mall     = 6    --商店类型
    self.PveStarTemple.Event    = 7    --对策
    self.PveStarTemple.Max      = 8    --最高

    self.eventConfigList[self.PveStarTemple.Drop] = DynamicConfigData.t_PveStarTempleDropConfig[self.PveStarTemple.Drop]
    self.eventConfigList[self.PveStarTemple.Buff] = DynamicConfigData.t_PveStarTempleBuffConfig[self.PveStarTemple.Buff]
    self.eventConfigList[self.PveStarTemple.Item] = DynamicConfigData.t_PveStarTempleItemConfig[self.PveStarTemple.Item]
    self.eventConfigList[self.PveStarTemple.Answer] = DynamicConfigData.t_PveStarTempleAnswerConfig
    self.eventConfigList[self.PveStarTemple.Npc] = DynamicConfigData.t_PveStarTempleNpcConfig[self.PveStarTemple.Npc][500]
    self.eventConfigList[self.PveStarTemple.Mall] = DynamicConfigData.t_PveStarTempleMallConfig[self.PveStarTemple.Mall]
    self.eventConfigList[self.PveStarTemple.Event] = DynamicConfigData.t_PveStarTempleEventConfig[self.PveStarTemple.Event]
end

function PveStarTempleModel:init()
    for k1,v1 in pairs(DynamicConfigData.t_PveStarTempleTaskConfig) do
        self.taskIDList[k1] = self.taskIDList[k1] or  {}
        for k2,v2 in pairs(v1) do
            self.taskIDList[k1][k2] = v2.taskId
        end
    end
end

function PveStarTempleModel:setPveStarTempleData(data)
    self:setRoundNumber(data.roundNumber)
    self:setRoundTime(data.roundTime)
    self:setLayer(data.layer)
    self:setMaxLayer(data.maxLayer)
    self:setAuto(data.auto)
    self:setSweep(data.sweep)
    self:setBattleFlag(data.battleFlag)
    self:setHeroList(data.hero or {})
    self:setMonsterList(data.monster or {})
    self:setAttrList(data.attr or {})
    self:setTaskList(data.task or {})
    self:setItemUseList(data.itemUseLimit or {})
    self:setAreaList(data.layerMaster or {})
    self:setExploreShop(data.exploreShop or {})
    self:setRoundLayer(data.roundLayer)
    self:setBattleFlag(data.battleFlag)
    if self.isReset then--如果回合数不同，说明发生重置
        self.isReset = false
        Dispatcher.dispatchEvent("PveStarTemple_Reset")
    end
end

--获取轮数
function PveStarTempleModel:getRoundNumber()
    return self.roundNumber or 1
end

--设置轮数
function PveStarTempleModel:setRoundNumber(roundNumber)
    if self.roundNumber and roundNumber then
        self.isReset = self.roundNumber ~= roundNumber
    end
    self.roundNumber = roundNumber
end

--获取剩余时间
function PveStarTempleModel:getRoundTime()
    return self.roundTime
end

--设置剩余时间
function PveStarTempleModel:setRoundTime(roundTime)
    self.roundTime = roundTime
end

--获取当前层
function PveStarTempleModel:getLayer()
    return self.layer or 1
end

--设置最高层
function PveStarTempleModel:setLayer(layer)
    self.layer = layer or 1
    self.layer = math.max(1,self.layer)
end

--获取最高层
function PveStarTempleModel:getMaxLayer()
    return self.maxLayer or 0
end

--设置最高层
function PveStarTempleModel:setMaxLayer(maxLayer)
    self.maxLayer = maxLayer
end

--设置轮回层数
function PveStarTempleModel:setRoundLayer(roundLayer)
    self.roundLayer = roundLayer or 0
end

--获取是否自动伞拾取
function PveStarTempleModel:getAuto()
    return self.auto or false
end

--设置自动拾取
function PveStarTempleModel:setAuto(auto)
    self.auto = auto or false
end

--是否可以扫荡
function PveStarTempleModel:canSweep()
    if self.maxLayer < self.layer then
        return false
    end

    local sweepStart,sweepEnd = self:getSweepLayer()
    print(999,"扫荡条件",sweepStart,sweepEnd)
    return self.layer >= sweepStart and self.layer <= sweepEnd
end

--获取可扫荡的起始层和结束层
function PveStarTempleModel:getSweepLayer()
    local reback = DynamicConfigData.t_PveStarTempleRoundConfig[self:getRoundNumber()].reback
    local sweepCount = DynamicConfigData.t_PveStarTempleRoundConfig[self:getRoundNumber()].sweeps
    local sweepStart = self.maxLayer - reback
    if sweepStart < 1 then
        sweepCount = 1
    end

    if self.roundLayer ~= 0 and sweepStart > self.roundLayer then
        sweepStart = self.roundLayer
    end

    local sweepEnd = sweepStart + sweepCount - 1
    if sweepEnd > self.maxLayer then
        sweepEnd = self.maxLayer
    end

    return sweepStart,sweepEnd
end

--是否扫荡过本层
function PveStarTempleModel:hasSweep()
    return self.sweep == self.layer
end

--设置扫荡
function PveStarTempleModel:setSweep(sweep)
    self.sweep = sweep
end

--获取是否跳过战斗
function PveStarTempleModel:getBattleFlag()
    return self.battleFlag or false
end

--设置跳过战斗
function PveStarTempleModel:setBattleFlag(battleFlag)
    self.battleFlag = battleFlag or false
end

--获取上阵应四栋数据 isFullData:是否包含星级种族等
function PveStarTempleModel:getHeroList(isFullData)
    if not isFullData then
        return self.heroList
    end

    if not isRefreshHeroList then
        return self.heroDataList
    end

    self.heroDataList = {}

    for k,v in ipairs(self.heroList) do
        for i,heroInfo in ipairs(self.allCard) do
            if heroInfo.uuid == v.uuid then
                heroInfo.hp = v.hp
                table.insert(self.heroDataList,heroInfo)
            end
        end
    end

    isRefreshHeroList = false
    return self.heroDataList
end


function PveStarTempleModel:getAllcombat()
	local combat=0
	local heroData = self:getHeroList(true)
	for k, v in pairs(heroData) do
		combat=combat+v.combat
	end
	return combat
end




--英雄是否全部阵亡
function PveStarTempleModel:isAllHeroDead()
    local ret = true
    for k,v in pairs(self.heroList) do
        if v.hp > 0 then
            ret = false
            break
        end
    end

    return ret
end

--获取血量不满的英雄
function PveStarTempleModel:getHPNotMaxHeroList()
    local ret = {}

    for k,v in ipairs(self.heroDataList) do
        if v.hp < v.maxHp and v.hp > 0 then
            table.insert(ret,v)
        end
    end


    return ret
end

--设置上阵英雄
function PveStarTempleModel:setHeroList(heroList)
    for k,v in pairs(self.heroList) do
        local hasFind = false
        for k1,v1 in pairs(heroList) do
            if v.uuid == v1.uuid then
                if v.hp ~= v1.hp then
                    isRefreshHeroList = true
                end
                hasFind = true
                break
            end
        end

        if not hasFind then
            isRefreshHeroList = true
        end

        if isRefreshHeroList then
            break
        end
    end

    self.heroList = {}

    for k,v in pairs(heroList) do
        table.insert(self.heroList,v)
    end

    table.sort(self.heroList,function(a,b)
        return a.pos < b.pos
    end)

    self:setRedPoint()
end

--更新英雄数据
function PveStarTempleModel:updateHero(data)
    isRefreshHeroList = true
    for k,v in pairs(self.heroList) do
        if v.uuid == data.uuid then
            self.heroList[k] = data
            break
        end
    end
end

--获取boss数据
function PveStarTempleModel:getMonster(areaID)
    return self.monsterList[areaID]
end

--获取剩余boss数量
function PveStarTempleModel:getRemainBossCount()
    local bossList = DynamicConfigData.t_PveStarTemplePartConfig[self.layer]
    local ret = 0
    for i,v in ipairs((bossList)) do
        local isBeated = self.layerMaster[v.area] and self.layerMaster[v.area].win
        if not isBeated then
            ret = ret + 1
        end
    end

    return ret
end

--获取boss
function PveStarTempleModel:getRemainBoss()
    local bossList = DynamicConfigData.t_PveStarTemplePartConfig[self.layer]
    local ret = {}
    for i,v in ipairs((bossList)) do
        local isBeated = self.layerMaster[v.area] and self.layerMaster[v.area].win
        table.insert(ret,{data = v,isBeated = isBeated})
    end

    return ret
end

--获取boss的完整数据
function PveStarTempleModel:getBossData(fightID,standID,areaIndex)
    local ret = {}
    local fightData = DynamicConfigData.t_fight[fightID]
    local monsterParam = fightData["attrParam"..standID]
    local areaMonster =  self:getMonster(areaIndex)
    ret.code = fightData["monsterId"..standID]
    ret.level = fightData["level"..standID]
    ret.star = fightData["star"..standID]
    local monsterData = DynamicConfigData.t_monster[ret.code]
    ret.maxHp = areaMonster and areaMonster.hpMax or monsterData.hp * monsterParam
    ret.hp = areaMonster and areaMonster.hp or monsterData.hp * monsterParam
    ret.category = monsterData.category
    ret.combat = fightData.monstercombat
    ret.uuid = false
    return ret
end

--设置boss数据
function PveStarTempleModel:setMonsterList(list)
    self.monsterList = list or {}
end

--更新boss数据
function PveStarTempleModel:updateMonster(data)
    for k,v in pairs(self.monsterList) do
        if v.areaId == data.areaId then
            self.monsterList[k] = data
            return
        end
    end

    self.monsterList[data.areaId] = data
end

--获取buff加成
function PveStarTempleModel:getAttrList()
    return self.attrList
end

--设置buff加成
function PveStarTempleModel:setAttrList(attrList)
    self.attrList = attrList or {}
end

--获取任务列表
function PveStarTempleModel:getTaskIDList()
    return self.taskIDList[self:getRoundNumber()]
end

-- 是否有未领取任务
function PveStarTempleModel:hasUnGetTask()
    for k,v in pairs(self.taskIDList[self:getRoundNumber()]) do
        local config = DynamicConfigData.t_PveStarTempleTaskConfig[self:getRoundNumber()][v]
        local taskCount = self:getTaskCount(config.recordType)
        if taskCount >= config.count then
            local hasGet = self:taskRewardHasGet(config.recordType,v)
            if not hasGet then
                return true
            end
        end
    end

    return false
end

--任务奖励是否已经领取
function PveStarTempleModel:taskRewardHasGet(taskType,id)
    if not self.taskHasGet[taskType] then
        return false
    end
    return self.taskHasGet[taskType][id] or false
end

--获取任务目标的达成数量
function PveStarTempleModel:getTaskCount(taskType)
    return self.taskList[taskType] and self.taskList[taskType].value or 0
end

--设置任务列表
function PveStarTempleModel:setTaskList(taskList)
    self.taskList = taskList
    self.taskHasGet = {}

    for k,v in pairs(taskList) do
        self.taskHasGet[k] = self.taskHasGet[k] or {}
        for k2,v2 in pairs(v.receive) do
            self.taskHasGet[k][v2] = true
        end
    end

    table.sort(self.taskIDList[self:getRoundNumber()],function(a,b)
        local taskAType = DynamicConfigData.t_PveStarTempleTaskConfig[self:getRoundNumber()][a].recordType
        local taskBType = DynamicConfigData.t_PveStarTempleTaskConfig[self:getRoundNumber()][b].recordType
        local aGet = self:taskRewardHasGet(taskAType,a)
        local bGet = self:taskRewardHasGet(taskBType,b)

        if aGet == bGet then
            return a < b
        else
            return not aGet
        end
    end)

    self:setRedPoint()
end

--更新任务
function PveStarTempleModel:updateTask(taskData)
    self.taskList[taskData.type] = taskData
    self:setTaskList(self.taskList)
    self:setRedPoint()
end

--更新已领取任务
function PveStarTempleModel:updateTaskHasGet(taskType,taskID)
    table.insert(self.taskList[taskType].receive,taskID)
    self:setTaskList(self.taskList)
    self:setRedPoint()
end

--获取道具使用次数
function PveStarTempleModel:getItemUseCount(code)
    return self.itemUseLimit[code] and self.itemUseLimit[code].count or 0
end

--设置道具使用次数
function PveStarTempleModel:setItemUseList(itemUseLimit)
    self.itemUseLimit = itemUseLimit or {}
end

--更新道具使用次数data
function PveStarTempleModel:updateItemUseList(data)
    for k,v in pairs(self.itemUseLimit) do
        if v.code == data.code then
            self.itemUseLimit[k] = data
            return
        end
    end

    self.itemUseLimit[data.code] = data
end

--获取区域数据
function PveStarTempleModel:getAreaList()
    return self.layerMaster
end

--检查区域是否有未领取的奖励
function PveStarTempleModel:checkAreaReward()
   --local have=false
   for k, v in pairs(self.layerMaster) do
		local events=v.event
		if next(events) then
		   for index, eventData in pairs(events) do
		   	   if eventData.flag~=1 then
					return true
			   end
		   end
		end
   	  
   end
   return false
end


--设置区域数据
function PveStarTempleModel:setAreaList(layerMaster)
    self.layerMaster = layerMaster
end

--更新某个区域的数据
function PveStarTempleModel:updateArea(areaData)
    self.layerMaster[areaData.areaId] = areaData
end

--更新区域事件
function PveStarTempleModel:updateAreaEvent(areaData)
    self.layerMaster[areaData.areaId].event[areaData.event.pos] = areaData.event
end

--获取探索商店
function PveStarTempleModel:getExploreShop()
    return self.exploreShop
end

--设置探索商店
function PveStarTempleModel:setExploreShop(exploreShop)
    self.exploreShop = exploreShop
end

--更新探索商店
function PveStarTempleModel:updateExploreShop(data)
    for k,v in pairs(self.exploreShop) do
        if v.uuid == data.uuid then
            self.exploreShop[k] = data
            return
        end
    end

    table.insert(self.exploreShop,data)
end

--增加探索商店道具
function PveStarTempleModel:addExploreShop(list)
    for k,v in pairs(list) do
        local hasFind = false
        for k2,v2 in pairs(self.exploreShop) do
            if v2.uuid == v.uuid then
                hasFind = true
                break
            end
        end

        if not hasFind then
            table.insert(self.exploreShop,v)
        end
    end
end

--获取神秘商店
function PveStarTempleModel:getMysteryShop()
    return self.mysteryShop
end

--设置神秘商店
function PveStarTempleModel:setMysteryShop(mysteryShop)
    self.mysteryShop = mysteryShop
end

--更新神秘商店单个物品
function PveStarTempleModel:updateMysteryShop(data)
    for k,v in pairs(self.mysteryShop) do
        if v.uuid == data.uuid then
            self.mysteryShop[k] = data
            return
        end
    end
end

--获取当前答题索引
function PveStarTempleModel:getCurrQuestionIndex()
    return self.currQuestionIndex
end

--设置当前答题索引
function PveStarTempleModel:setCurrQuestionIndex(index)
    self.currQuestionIndex = index
end

--获取当前题目
function PveStarTempleModel:getCurrQuestionList()
    return self.currQuestionList
end

--设置当前答题索引
function PveStarTempleModel:setCurrQuestionList(questionList)
    self.currQuestionList = questionList
end

--设置上阵英雄
function PveStarTempleModel:setSelectHero(heroList)
    local list = {}
    local sendList = {}
    for i,v in ipairs(heroList) do
        list[v.uuid] = {
            uuid = v.uuid,
            hp = v.hp,
            pos = i,
        }
        table.insert(sendList,v.uuid)
    end
    self:setHeroList(list)
    Dispatcher.dispatchEvent(EventType.PveStarTemple_SetArrayHeroInfo,sendList)
end

--获取当前选择的对策的唯一id
function PveStarTempleModel:getCurrEventOnlyID()
    return self.currEventOnlyID
end

--设置当前选择的对策的唯一id
function PveStarTempleModel:setCurrEventOnlyID(onlyID)
    self.currEventOnlyID = onlyID
end

--获取事件配置
function PveStarTempleModel:getEventConfig(type,id,onlyId)
    if not self.eventConfigList[type] then
        return nil
    end

    local ret = nil
    local config = self.eventConfigList[type]
    if not config then
        return ret
    end

    for k,v in pairs(self.eventConfigList[type]) do
        if onlyId and onlyId ~= 0 then
            if v.onlyId == onlyId then
                ret = v
                break
            end
        else
            if v.id == id then
                ret = v
                break
            end
        end
    end

    return ret
end

--获取物品使用次数
function PveStarTempleModel:getItemUseLimit(code)
    local config = DynamicConfigData.t_PveStarTempleRoundConfig[self:getRoundNumber()]
    for k,v in pairs(config.itemUseLimit) do
        if v.code == code then
            return v.count
        end
    end

    return 0
end

--根据种族获取卡牌
function PveStarTempleModel:getCardsByCategory(category)
    if category == 0 then
        return self.allCard
    end

    local ret = {}
    for i,v in ipairs(self.allCard) do
        if v.category == category then
            table.insert(ret,v)
        end
    end

    return ret
end

--是否持有卡牌
function PveStarTempleModel:hasCard()
    return #self.allCard > 0
end

--设置所有卡牌
function PveStarTempleModel:setAllCard(list)
    self.allCard = {}
    isRefreshHeroList = true
    if not list then
        return
    end

    for i,v in ipairs(list) do
        table.insert(self.allCard,deepcopy(v))
    end
end

--根据数据设置红点
function PveStarTempleModel:setRedPoint()
    local hasOpen = ModuleUtil.moduleOpen(ModuleId.PveStarTemple.id, false)
    RedManager.updateValue("V_PVESTARTEMPLE", #self.heroList < 1 and hasOpen)

    if not self.roundNumber or self.roundNumber < 1 then
        return
    end
    local hasUnGetTaks = self:hasUnGetTask()
    RedManager.updateValue("V_PVESTARTEMPLE_TASK", hasUnGetTaks and hasOpen)
end

function PveStarTempleModel:setSelectHeroIndex(index)
    self.currSelectHeroIndex=index
end

function PveStarTempleModel:getSelectHeroIndex()

	if not self.currSelectHeroIndex then
		self.selectHeroData = {}
		for k,v in pairs(ModelManager.PveStarTempleModel:getHeroList(true)) do
			table.insert(self.selectHeroData,v)
		end

		table.sort(self.selectHeroData,function (a,b)
				return a.combat > b.combat
		end)
		for i,v in ipairs(self.selectHeroData) do
			if v.hp > 0 then
				self.currSelectHeroIndex = i
				break
			end
		end
	end
	
	if not self.currSelectHeroIndex then self.currSelectHeroIndex = 1 end
	return self.currSelectHeroIndex 
end



--保存提示配置
function PveStarTempleModel:saveTodayAlerConfig(check)
	local nowDay= tostring(TimeLib.getDay())
	if check then
		FileCacheManager.setStringForKey(PlayerModel.userid..FileDataType.PVESTARSHOWALER,nowDay,nil,true)
	else
		FileCacheManager.setStringForKey(PlayerModel.userid..FileDataType.PVESTARSHOWALER,"0",nil,true)
	end
end

--判断是否玩家已经勾选了今日不再提示
function PveStarTempleModel:todayShowAler()
	local checkString= FileCacheManager.getStringForKey(PlayerModel.userid..FileDataType.PVESTARSHOWALER,"0",nil,true)
	local nowDay= tostring(TimeLib.getDay())
	return checkString~=nowDay
end




function PveStarTempleModel:addLayerReward(data)
	for k,v in ipairs(data) do
		local hasFind = false
		for k2,v2 in ipairs(self.layerReward) do
			if v2.code == v.code then
				v2.amount = v2.amount + v.amount
				hasFind = true
				break
			end
		end
		if not hasFind then
			table.insert(self.layerReward,v)
		end
	end
	Dispatcher.dispatchEvent(EventType.PveStarTemple_updateLayerReward)
	
end



function PveStarTempleModel:setLayerReward(data)
	local rewards = {}
	if data then
		for k,v in ipairs(data) do
			local hasFind = false
			for k2,v2 in ipairs(rewards) do
				if v2.code == v.code then
					v2.amount = v2.amount + v.amount
					hasFind = true
					break
				end
			end

			if not hasFind then
				table.insert(rewards,v)
			end
		end
	end	
	self.layerReward=rewards
end





return PveStarTempleModel