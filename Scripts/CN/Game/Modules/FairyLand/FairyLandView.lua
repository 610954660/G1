--Name : FairyLandView.lua
--Author : generated by FairyGUI
--Date : 2020-4-15
--Desc : 

local FairyLandView,Super = class("FairyLandView", Window)
local FairyLandRoll = require "Game.Modules.FairyLand.FairyLandRoll"
local FairyLandMapRect = require "Game.Modules.FairyLand.FairyLandMapRect"

function FairyLandView:ctor(args)
	--LuaLog("FairyLandView ctor")
	self._packName = "FairyLand"
	self._compName = "FairyLandView"
	self._rootDepth = LayerDepth.Window
	self._showParticle=true
	self.guochangyun=false
	self._updateTimeId=false
	self.args = args
	self._roll = false
	self._mapRect = false
	self.recoardBoard = false
	
	--self._waitBattle = true --如果有战斗未结束跳转到这里需要等待战斗结束
	
	self._curPosIndex = 1
	self._curMapMaxIndex = 20
	
	self._grid = 1
	self.reward = {}
	
	self._recordData = {}
	
	self.list_record = false
	self.nextState = false

	self.itemLucky = false 
	self.btn_treasure = false

	self.btn_rank	= false
	self.autoCloseTime = 2 --奖励自动关闭时间
	
	self.autoNextMapTimer = false
end

function FairyLandView:_initEvent( )
	
end

function FairyLandView:_initVM( )

	FairyLandModel.moving = false
	local vmRoot = self
	local viewNode = self.view
	---Do not modify following code--------
	--{vmFields}:FairyLand.FairyLandView
		vmRoot.com_map = viewNode:getChildAutoType("$com_map")--
		vmRoot.btn_help = viewNode:getChildAutoType("$btn_help")--Button
		vmRoot.com_roll = viewNode:getChildAutoType("$com_roll")--
		vmRoot.img_animation = viewNode:getChildAutoType("$img_animation")--loader
		vmRoot.btn_nextMap = viewNode:getChildAutoType("$btn_nextMap")--Button
		vmRoot.txt_layer = viewNode:getChildAutoType("$txt_layer")--text
		vmRoot.btn_exit = viewNode:getChildAutoType("$btn_exit")--Button
		vmRoot.recoardBoard = viewNode:getChildAutoType("$recoardBoard")--
		vmRoot.itemLucky 	= viewNode:getChildAutoType("$itemLucky")
		vmRoot.btn_treasure = viewNode:getChildAutoType("$btn_treasure")
		vmRoot.btn_rank 	= viewNode:getChildAutoType("$btn_rank")
		vmRoot.btn_speed 	= viewNode:getChildAutoType("$btn_speed")
		vmRoot.btn_shop 	= viewNode:getChildAutoType("$btn_shop")
	--{vmFieldsEnd}:FairyLand.FairyLandView
	--Do not modify above code-------------
	
	self.btn_shop:setVisible(false)
	self.recoardBoard = BindManager.bindRewardRecordBoard(self.recoardBoard)
	viewNode:getChildAutoType("frame"):getController("c1"):setSelectedIndex(1)
	self.com_map:setSize(display.width, display.height)
	self.com_map:setPosition(-(display.width - self.view:getWidth())/2, 0)
	vmRoot.nextMap = viewNode:getChildAutoType("nextMap")--Button
	
	 self.btn_nextMap:addClickListener(function( ... )
		self:toNextMap()
       end) 

	self.btn_help:addClickListener(function( ... )
		RollTips.showHelp(Desc.fairyLand_helpTitle, Desc.fairyLand_helpText)
       end)

	self.btn_exit:addClickListener(function( ... )
		self:closeView()
       end)

	self.btn_rank:addClickListener(function()
		ViewManager.open("FairyLandRankView",{type = GameDef.RankType.FairyLandFloor})
		--self._mapRect:playInEffect()
	end)

	self.btn_shop:addClickListener(function()
		ModuleUtil.openModule( ModuleId.Shop.id , true,{shopType = 12} )
		--self._mapRect:playOutEffect()
	end)

	
	self._roll =  FairyLandRoll.new(self.com_roll)
	self._mapRect = FairyLandMapRect.new(self.com_map)
	self._roll:setCompleteCallBack(self, self.fairyLand_moveNextGrid)
	self._mapRect:setToPos(self._curPosIndex)
	self._mapRect:initMap()
	--self:updateLayerInfo()
	self._roll:initData(self.args)
	--self:fairyLand_moveComplete()
	self:updateLayerInfo()

	self.btn_speed:addClickListener(function()
		local ctrl = self.btn_speed:getController("c1")
		local index = ctrl:getSelectedIndex()
		local isUp  = index == 0 and true or false
		index = index == 0 and 1 or 0
		ctrl:setSelectedIndex(index)
		self._roll:isSpeedUp(isUp)
		self._mapRect:isSpeedUp(isUp)
		print(8848,">>>>>>>>>>>>>>>>>>>> index >>>>",index)
	end)
end


function FairyLandView:fairyLand_cancelAuto()
	self._roll:fairyLand_cancelAuto()
end

function FairyLandView:fairyLand_onRwardClose()
	ModelManager.FairyLandModel:addGetRewardGrid()
	ModelManager.FairyLandModel.reward = false
	self:fairyLand_moveNextGrid()
end

function FairyLandView:fairyLand_moveComplete()
	--ModelManager.FairyLandModel.moveNum = ModelManager.FairyLandModel.moveNum - 1
	local configInfo = DynamicConfigData.t_fairyLand[ModelManager.FairyLandModel.floor][ModelManager.FairyLandModel.grid]
	if(ModelManager.FairyLandModel.gridInfo) then
		if(configInfo.type == GameDef.FairyLandGridType.Guarder) then
			local callBack = function(type)
				if(type == "begin") then
					local params = {}
					params.onSuccess = function (res )
						--printTable(1, res)
						local gridInfo = ModelManager.FairyLandModel.gridInfo
						ModelManager.FairyLandModel:updateInfo(res.data)
						local params = {}
						params.isWin = res.result
						params.reward = ModelManager.FairyLandModel.reward
						params.type = GameDef.GamePlayType.FairyLand
						params.autoCloseTime = 2
						--printTable(1,"11111111111111111111111",params)
						params.closeCallBack = self.fairyLand_moveNextGrid
						params.closeCaller = self
						ModelManager.PlayerModel:set_awardData(params)
						ModelManager.FairyLandModel.reward = false
					end
					RPCReq.FairyLand_Action(params, params.onSuccess)
				elseif(type == "end") then 
					--ViewManager.open("AwardShowView",{reward = ModelManager.FairyLandModel.reward, closeCallback = self.fairyLand_moveNextGrid, closeCaller = self})
					ModelManager.FairyLandModel.gridInfo = false
					ModelManager.FairyLandModel:addGetRewardGrid()
					--self:fairyLand_moveNextGrid()
				elseif(type == "cancel") then
					self:onFightCancel()
				end
			end
	
			local configType=GameDef.BattleArrayType.FairyLand
			if FairyLandModel.autoNext then
				Dispatcher.dispatchEvent(EventType.battle_requestFunc,callBack, {fightID=ConstConfiger.getValueByKey("FairyLandGuarderFightId"),configType=configType, autoStartTime = 2, autoCloseTime = 2})
			else
				Dispatcher.dispatchEvent(EventType.battle_requestFunc,callBack, {fightID=ConstConfiger.getValueByKey("FairyLandGuarderFightId"),configType=configType})
			end
		elseif(configInfo.type == GameDef.FairyLandGridType.Question) then

			ViewManager.open("FairyLandQuestionView", ModelManager.FairyLandModel.gridInfo)
		elseif(configInfo.type == GameDef.FairyLandGridType.Ending) then
			if ModelManager.FairyLandModel:reachTimesLimit() then
				self.nextMap:setVisible(true)
				local nextFloor = DynamicConfigData.t_fairyLand[ModelManager.FairyLandModel.floor + 1]
				local index = nextFloor and 0 or 1
				self.view:getController("c1"):setSelectedIndex(0)
				if FairyLandModel.autoNext then
					if self.autoNextMapTimer then Scheduler.unschedule(self.autoNextMapTimer) end
					self.autoNextMapTimer  = Scheduler.scheduleOnce(self.autoCloseTime*2, function()
						self.btn_nextMap:dispatchEvent(FUIEventType.Click)	
					end) --因为最后一格有奖励，要等奖励关闭了才能再点
				end
			end
		elseif(configInfo.type == GameDef.FairyLandGridType.Reward) then
			if(ModelManager.FairyLandModel.reward) then
				local curItem = self._mapRect:getItem(ModelManager.FairyLandModel.grid)
				for k,v in pairs(ModelManager.FairyLandModel.reward) do
					table.insert(self.reward,v)
				end
				if FairyLandModel.status > 0 then
					if FairyLandModel.moveNum == 0 then
						RollTips.showReward(self.reward, function()
							Dispatcher.dispatchEvent(EventType.fairyLand_onRwardClose)
						end, FairyLandModel.autoNext and self.autoCloseTime or -1)
						self.reward = {}
					end
				else
					RollTips.showReward(ModelManager.FairyLandModel.reward,function()
							Dispatcher.dispatchEvent(EventType.fairyLand_onRwardClose)
						end, FairyLandModel.autoNext and self.autoCloseTime or -1)
					self.reward = {}
				end
				
				ModelManager.FairyLandModel:addGetRewardGrid()
				ModelManager.FairyLandModel.reward = false
				self:fairyLand_moveNextGrid()
			else
				self:fairyLand_moveNextGrid()
			end
		end
	elseif(ModelManager.FairyLandModel.reward) then
		local curItem = self._mapRect:getItem(ModelManager.FairyLandModel.grid)
		--RollTips.flyReward(ModelManager.FairyLandModel.reward, curItem)
		if not self.reward then self.reward = {} end
		local reward = ModelManager.FairyLandModel.reward
		for k,v in pairs(reward) do
			table.insert(self.reward,v)
		end
		local onRewardClose = function ()
			ModelManager.FairyLandModel:addGetRewardGrid()
			ModelManager.FairyLandModel.reward = false
			self:fairyLand_moveNextGrid()
		end
		if FairyLandModel.status > 0 then
			if FairyLandModel.moveNum == 0 then
				RollTips.showReward(self.reward,onRewardClose, FairyLandModel.autoNext and self.autoCloseTime or -1)
				self.reward = {}
			else
				onRewardClose()
			end
		else
			RollTips.showReward(ModelManager.FairyLandModel.reward, onRewardClose, FairyLandModel.autoNext and self.autoCloseTime or -1)
			self.reward = {}
		end
		

	elseif (configInfo.type == GameDef.FairyLandGridType.Magnet) and (ModelManager.FairyLandModel.moveNum == 0) then
		ModelManager.FairyLandModel:addGetRewardGrid()
		self:fairyLand_moveNextGrid()
	else
		self:fairyLand_moveNextGrid()
	end
end


function FairyLandView:onFightCancel()
	local info = {}
	info.text = Desc.fairyLand_cancelFight
	info.type = "yes_no"
	info.yesText = Desc.fairyLand_continueFight
	info.noText = Desc.fairyLand_closeView
	info.mask = true
	info.onYes = function()
		self:fairyLand_moveComplete()
	end
	info.onNo = function()
		self:closeView()
	end
	Alert.show(info)
end


function FairyLandView:updateLayerInfo()
	self.txt_layer:setText(ModelManager.FairyLandModel.floorFlag)
	self._roll.view:getController("autoCtrl"):setSelectedIndex( ModelManager.FairyLandModel.floorFlag > 2 and 1 or 0)
	self._recordData = {}
	local equipData = {code = 20001206,amount= 0} --装备固定用这个图标
	for _,v in pairs(ModelManager.FairyLandModel.records) do
		local itemInfo = DynamicConfigData.t_item[v.code]
		if itemInfo and itemInfo.category == GameDef.Category.Equipment then
			equipData.amount = equipData.amount + v.amount
		else
			table.insert(self._recordData, v)
		end
	end
	if equipData.amount > 0 then
		TableUtil.insertTo(self._recordData, 1, equipData)
	end
	self.recoardBoard:setData(self._recordData)

	self:refreshLucky()
	self:refreshProgress()
end

function FairyLandView:toNextMap()
	-- if(not DynamicConfigData.t_fairyLand[ModelManager.FairyLandModel.floor + 1]) then
	-- 	RollTips.show(Desc.fairyLand_noNextMap)
	-- 	--self:closeView()
	-- 	return;
	-- end
	if self.autoNextMapTimer then Scheduler.unschedule(self.autoNextMapTimer) end
	
	local params = {}
	params.onSuccess = function (res )
		--printTable(1, res)
		self.nextMap:setVisible(false)
		ModelManager.FairyLandModel:updateInfo(res.data)
		local reward = ModelManager.FairyLandModel.reward
		ModelManager.FairyLandModel.reward = false
		RollTips.showReward(reward, function()
			if tolua.isnull(self.view) then return end
			self._mapRect:playOutEffect(function ()
				self._mapRect._isInit = false
				self._mapRect:initMap(true)
				self:updateLayerInfo()
				self:showNextMapExcessive(function ()
					self._mapRect:playInEffect(function ()
						self._roll:open(true)
					end)
				end);
			end)
		end, FairyLandModel.autoNext and self.autoCloseTime or -1)
	end
	params.onFail = function (errorMsg)
		RollTips.showError(errorMsg)
		self.nextMap:setVisible(true)
	end
	RPCReq.FairyLand_Action(params, params.onSuccess, params.onFail)
	
end

--[[function FairyLandView:updateLayerInfo()
	self.txt_layer:setText(ModelManager.FairyLandModel.floor)
end--]]

function FairyLandView:showNextMapExcessive(onComplete)
	if not self.guochangyun then
		self.guochangyun= SpineUtil.createSpineObj(self.img_animation,{x=0,y=0}, "animation", "Effect/UI", "Ef_guochangyun", "Ef_guochangyun",false) 
	end
		self.guochangyun:setAnimation(0, "animation", false)
		self.guochangyun:setCompleteListener(function(name)
			if onComplete ~= nil then
				onComplete()
			end
		end)
	   self._updateTimeId = Scheduler.scheduleOnce(0.8,function()
		  self._updateTimeId=false
	end)
end

function FairyLandView:fairyLand_updateInfo()
	self:updateLayerInfo()
	--self.txt_layer:setText(ModelManager.FairyLandModel.floor)
end

function FairyLandView:FairyLand_UpdateFairyLandData(_,params)
	--RollTips.show(Desc.fairyLand_answerTimeout
end


function FairyLandView:fairyLand_end()
	local nextFloor = DynamicConfigData.t_fairyLand[ModelManager.FairyLandModel.floor + 1]
	self.nextMap:setVisible(true)
	local index = nextFloor and 0 or 1
	self.view:getController("c1"):setSelectedIndex(0)
	if FairyLandModel.autoNext then
		if self.autoNextMapTimer then 	Scheduler.unschedule(self.autoNextMapTimer) end
			self.autoNextMapTimer  = Scheduler.scheduleOnce(self.autoCloseTime*2, function()
				self.btn_nextMap:dispatchEvent(FUIEventType.Click)	
			end) --因为最后一格有奖励，要等奖励关闭了才能再点
		end
	return;
end


function FairyLandView:fairyLand_moveNextGrid()
	if(ModelManager.FairyLandModel.gridInfo) then
		local configInfo = DynamicConfigData.t_fairyLand[ModelManager.FairyLandModel.floor][ModelManager.FairyLandModel.grid]
		local nextFloor = DynamicConfigData.t_fairyLand[ModelManager.FairyLandModel.floor + 1]
		if(configInfo.type == GameDef.FairyLandGridType.Ending) then
			if ModelManager.FairyLandModel:reachTimesLimit() then
				self.nextMap:setVisible(true)
				local index = nextFloor and 0 or 1
				self.view:getController("c1"):setSelectedIndex(0)
				if FairyLandModel.autoNext then
					if self.autoNextMapTimer then 	Scheduler.unschedule(self.autoNextMapTimer) end
					self.autoNextMapTimer  = Scheduler.scheduleOnce(self.autoCloseTime*2, function()
						self.btn_nextMap:dispatchEvent(FUIEventType.Click)	
					end) --因为最后一格有奖励，要等奖励关闭了才能再点
				end
				return;
			end
		end
	end
	if ModelManager.FairyLandModel.moveNum > 0 then
		local params = {}
		params.onSuccess = function (res )
			--printTable(1, res)
			ModelManager.FairyLandModel:updateInfo(res.data)
			if tolua.isnull(self.view) then return end
			self._mapRect:addMovePoint({ModelManager.FairyLandModel.grid})
			
		end
		RPCReq.FairyLand_Move(params, params.onSuccess)
		self._grid = self._grid + 1
		ModelManager.FairyLandModel.moveNum = ModelManager.FairyLandModel.moveNum - 1
		local config = DynamicConfigData.t_fairyLand[1][self._grid]
	else
		self._roll:open(true)
	end
end


function FairyLandView:refreshLucky()
	local txt_luckyDec = self.itemLucky:getChildAutoType("txt_luckyDec")
	local txt_luckyTime = self.itemLucky:getChildAutoType("txt_luckyTime")

	local day = TimeLib.DayInWeek()
	local data = DynamicConfigData.t_lucky[day]
	local luckEventTimes = FairyLandModel:getLuckEventTimes()
	if not data then return end
	txt_luckyDec:setText(string.format(Desc.fairyLand_luckyDec,data.title))
	if day == 5 then
		txt_luckyTime:setText(Desc.fairyLand_luckyTime2)
	else
		txt_luckyTime:setText(string.format(Desc.fairyLand_luckyTime,luckEventTimes))
	end
end

function FairyLandView:fairyLand_refresh()
	self:refreshLucky()
	self:refreshProgress()
	self._roll:updateForwardTime()
end


function FairyLandView:refreshProgress()
	local floor 	= FairyLandModel.floorFlag
	local sieveTimes = FairyLandModel.sieveTimes
	floor = floor > 7 and 7 or floor
	local data 		=  DynamicConfigData.t_times[floor]
	local progress 	= self.btn_treasure:getChildAutoType("progress")
	local txt_times = self.btn_treasure:getChildAutoType("txt_times")

	if not data then return end

	local info = {data=data,sieveTimes = sieveTimes}
	-- if sieveTimes >= data.timeslimit and  (not ModelManager.FairyLandModel.isGetSieveReward)then
	-- 	RPCReq.FairyLand_GetTimesReward({},function(param)
	-- 		FileCacheManager.setIntForKey("FairyLand_floor",ModelManager.FairyLandModel.floorFlag)
	-- 		FileCacheManager.setBoolForKey("FairyLand_reward",true)
	-- 	end)
	-- end

	self.btn_treasure:removeClickListener(22)
	self.btn_treasure:addClickListener(function()
		ViewManager.open("FairyLandTreasureRewardView",info)
	end,22)

	progress:setMax(data.timeslimit)
	progress:setValue(sieveTimes)
	txt_times:setText(string.format(Desc.fairyLand_boxTimes,sieveTimes,data.timeslimit))
end

function FairyLandView:_initUI( )
	self:_initVM()
	
end

function FairyLandView:_exit()
	FairyLandModel.autoNext = false
	SpineUtil.clearEffect(self.guochangyun)
    Scheduler.unschedule(self._updateTimeId)
end

return FairyLandView