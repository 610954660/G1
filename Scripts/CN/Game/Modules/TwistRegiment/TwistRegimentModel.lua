--Name : TwistRegimentModel.lua
--Author : generated by FairyGUI
--Date : 2020-4-15
--Desc :


local TwistRegimentModel = class("TwistRegimentModel", BaseModel)


function TwistRegimentModel:ctor()
	self.floor = 1 --当前在第几层
	self.floorFlag = 1
	self.grid = 0 --当前在第几格
	self.moveNum = 0 --还可以移动的步数
	self.status = 0 --状态 1磁铁
	self.gridInfo = false --当前格子数据
	self.gotRewards = {} --已经领取奖励的格子
	self.reward = false --当前格的奖励
	self.records = {} --当前层的奖励

	self.forWardTime = 0  -- 今日剩余免费随机前进次数
	self.luckEventTimes = 0 -- 每日剩余幸运事件次数
	self.sieveTimes 	= 0 -- 本层掷筛子次数
	self.isGetSieveReward = false
	
	self.monopolyData=false
	self.hadShowReward=false
	
	
	
	self.commonTimes=0  -- 今日剩余免费随机前进次数
	
	self.specialTimes=0-- 本层掷筛子次数
	self.cellInfoMap={}
	
	
	self.moving 	= false -- 是否在移动中

	self.mapIndex 	= 1 	-- 地图选择
	
	self.rewardTimes=1      --第几次奖励模板
	
	
	self.mapInfo={}	
	self.ativeData={}
	self.activeEnd=false
	self.addStep=0
	local keyArr1={}
	table.insert(keyArr1, "V_ACTIVITY_"..GameDef.ActivityType.Monopoly .. "commonTimes")
	table.insert(keyArr1, "V_ACTIVITY_"..GameDef.ActivityType.Monopoly .. "specialTimes")
	RedManager.addMap("V_ACTIVITY_"..GameDef.ActivityType.Monopoly, keyArr1)

end


function TwistRegimentModel:addGetRewardGrid()
	if not self.gotRewards[self.floor] then
		self.gotRewards[self.floor] = {}
	end
	table.insert(self.gotRewards[self.floor], self.grid)
	Dispatcher.dispatchEvent(EventType.fairyLand_gotRewardUpdate, {floor = self.floor, grid = self.grid})
end


--这个是更新信息
function TwistRegimentModel:updateInfo(info)
	-- printTable(8848,"info",info)
	if(not info) then return end
	if  info then
		self.reward = info
	end
end



function TwistRegimentModel:initData()
	
end

function TwistRegimentModel:getAcitveData()
    return self.ativeData
end




--这个是登陆时获取到的信息
function TwistRegimentModel:updateData(info)
	printTable(5656,info,"info")
	self.grid=info.id
	self.commonTimes=info.commonTimes
	self.specialTimes=info.specialTimes
	self.cellInfoMap=info.cellInfoMap
	--self.isAct=info.
	self.ativeData=info
	local acConfig=ActivityModel:getActityByType(GameDef.ActivityType.Monopoly)
	if acConfig then
		self.rewardTimes=acConfig.showContent.moduleId or 1
	end

	Dispatcher.dispatchEvent(EventType.TwistRegimentView_refreshPanel)
	self:redCheck()
	
end

function TwistRegimentModel:getAcitveConfig()
    return DynamicConfigData.t_monopoly[self.rewardTimes]
end


-- 获取每日剩余免费随机前进次数
function TwistRegimentModel:getFreeForwardTime()
	return self.forWardTime
end

function TwistRegimentModel:setFreeForwardTime(time)
	self.forWardTime = time
end

-- 每日剩余幸运事件次数
function TwistRegimentModel:getLuckEventTimes()
	return self.luckEventTimes
end


--是否奖励已领取
function TwistRegimentModel:isRewardGot(floor, grid)
	if self.gotRewards[floor] then
		for _,v in pairs(self.gotRewards[floor]) do
			if(v == grid) then
				return true
			end
		end
	end
	return false
end

--function TwistRegimentModel:redCheck()
	--RedManager.updateValue("V_FAIRYLAND", ModelManager.PackModel:getItemsFromAllPackByCode(10000023) > 0)
	--RedManager.updateValue("V_FAIRYLAND_EX", ModelManager.PackModel:getItemsFromAllPackByCode(10000024) > 0)
--end


--#大富翁 要色子协议
function TwistRegimentModel:monopoly_Shake(shakeType,addStep,callBack)
	local params = {}
	params.shakeType = shakeType  --指定色子
	params.addStep = addStep
	params.activityType=GameDef.ActivityType.Monopoly
	params.onSuccess = function (res ) 
		printTable(5656,res,"monopoly_Shake")
		callBack(true,res)
	end
	params.onFail = function (info)
		if GameDef.ErrorCodeDict[info.repError] then
			RollTips.show(GameDef.ErrorCodeDict[info.repError].desc)
		else
			RollTips.show("erroe code = "..info.repError)
		end
		callBack(false)
	end
	RPCReq.Activity_Monopoly_Shake(params, params.onSuccess,params.onFail)
end


function TwistRegimentModel:Activity_Monopoly_Buy()
	
	local costData=DynamicConfigData.t_monopolyCost[1]
	local leftCount=costData.limit-self.ativeData.buyTimes
	
	if leftCount<1 then
		RollTips.show(DescAuto[335]) -- [335]="购买次数已用完"
		return 
	end
	--cost[1].amount
	local info = {}
	info.text = string.format(Desc.sevenActivity_buy_text1, costData.cost[1].amount, DescAuto[336]).."\n"..string.format(Desc.TwistRegiment_limitBuyTimes,leftCount) -- [336]="命运骰子"
	info.title = DescAuto[337] -- [337]="次数购买"
	info.type = "yes_no"
	--info.yesText = Desc.fairyLand_continueFight
	--info.noText = Desc.fairyLand_closeView
	info.mask = true
	info.onYes = function()
		local params = {}
		params.activityType=GameDef.ActivityType.Monopoly
		params.onSuccess = function ()

		end
		RPCReq.Activity_Monopoly_Buy(params, params.onSuccess)
	end
	info.onNo = function()
		
	end
	Alert.show(info)
end




function TwistRegimentModel:joinBattleEvent(indexId,fightId,finished)
	local configType=GameDef.BattleArrayType.Monopoly
	local fightID=fightId
	local indexID=indexId
	local isWin=false
	local dataParamas={}
	local params = {
		id=indexID
	}
	local callBack = function(type)
		if(type == "begin") then
			params.onSuccess = function (res )
				ModelManager.TwistRegimentModel:updateInfo(res.addRes)
				params = {}
				params.isWin = res.result
				if params.isWin  then
					params.reward =res.addRes
					params.type = GameDef.GamePlayType.ActivityMonopoly
					--ModelManager.PlayerModel:set_awardData(params)
					--self.gridStateCtr:setSelectedPage("defeated")
				end
				dataParamas.reward =res.addRes
				isWin=params.isWin
			end
			RPCReq.Activity_Monopoly_Fight(params, params.onSuccess)
		elseif(type == "end") then
			  local function againChallege()
				     self:joinBattleEvent(indexID,fightID)
			  end
			  --printTable(5656,dataParamas,"dataParamas")
			  self:setGirdCanFight(isWin)
			  ViewManager.open("ReWardView",{page=4,type=1,data=dataParamas,isWin=isWin,arrayType=configType,againFunc=againChallege})
			  if finished then
				 finished()
			  end
		elseif(type == "cancel") then
			  self:onFightCancel(indexId,fightId,finished)
		end
	end
	Dispatcher.dispatchEvent(EventType.battle_requestFunc,callBack, {fightID=fightID,configType=configType})
end


function TwistRegimentModel:onFightCancel(indexId,fightId,finished)
	local info = {}
	info.text = DescAuto[338] -- [338]="需要击败四个领主怪物才能挑战大魔王"
	info.type = "yes_no"
	info.yesText = Desc.fairyLand_continueFight
	info.noText = DescAuto[339] -- [339]="放弃"
	info.mask = true
	info.onYes = function()
		self:joinBattleEvent(indexId,fightId,finished)
	end
	info.onNo = function()
		if finished then
			finished()
		end
		RPCReq.Activity_Monopoly_GiveUp({activityType=GameDef.ActivityType.Monopoly},function ()
			
		end)
		
		self:setGirdCanFight(false)
		--ViewManager.close("TwistRegimentView")
	end
	Alert.show(info)
end


--boss奖励预览
function TwistRegimentModel:showRewardView(gridData)
	--检测扫荡处理
	
	local info = {}
	info.text = ""
	info.title = DescAuto[334] -- [334]="奖励预览"
	info.rewardPre=gridData.p6
	--info.yesText=self.btnSweep:getText()
	--info.activeType=GameDef.BattleArrayType.Monopoly
	info.key ="AlertRewardView"
	Alert.show(info)
end



function TwistRegimentModel:redCheck()
	GlobalUtil.delayCallOnce("TwistRegimentModel:redCheck",function()
			self:updateRed()
	end, self, 0.1)
end

function TwistRegimentModel:updateRed()
	RedManager.updateValue("V_ACTIVITY_"..GameDef.ActivityType.Monopoly, self.ativeData.isOpenBoss or self.ativeData.commonTimes>0 or self.ativeData.specialTimes>0)
end




--改变格子挑战转头
function TwistRegimentModel:setGirdCanFight(can)
	FileCacheManager.setBoolForKey(PlayerModel.userid..FileDataType.TWiST_REGIT_GRID,can,false,false)
end

--是否能挑战这个格子
function TwistRegimentModel:isGirdCanFight()
	return FileCacheManager.getBoolForKey(PlayerModel.userid..FileDataType.TWiST_REGIT_GRID,false,false,false)
end




function TwistRegimentModel:init()

end


return TwistRegimentModel
