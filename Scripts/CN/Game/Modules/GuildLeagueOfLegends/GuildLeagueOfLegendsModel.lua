--Date :2020-12-31
--Author : generated by FairyGUI
--Desc : 

local GuildLeagueOfLegendsModel = class("GuildLeagueOfLegends", BaseModel)

function GuildLeagueOfLegendsModel:ctor()
    self:initListeners();
    self.guildMap = {};
    self.isInMatch = false; -- 自己公会是否参赛
    self.matchRound = 0; -- 比赛阶段
    self.roundState = 0; -- 阶段所处状态
    self.stateStamp = 0; -- 阶段结束时间戳
    self.groupInfo = {}; -- 比赛分组信息 
    self.posInfo = {}; -- key为完整的位置key
    self.myGuessInfo = {};
    self.guessInfo = {};
    self.guessState = 0; -- 0是无法进入竞猜
    self.guessGroup = -1;
    self.posList = {
        "3_1",
        "3_2",
        "3_3",
        "3_4",
        "3_5",
        "3_6",
        "3_7",
        "3_8",
        "2_1",
        "2_2",
        "2_3",
        "2_4",
        "1_1",
        "1_2",
        "0_1",
    }
    self.lineList = {
        "0_1",
        "1_1",
        "1_2",
        "2_1",
        "2_2",
        "2_3",
        "2_4"
    }
    self.allTeamInfo = {}
    self.heroInTeamMap = {}; -- 已经上阵的英雄 以heroCode为key 用于是否上阵其他队伍检测(本玩法三个队伍)
    self.curTeamIdx = 1; -- 1 队伍一  2 队伍二  3 队伍三
    self.fastEnter = true;
    self.fightTimer = {};
    self.notEnoughGuild = false;
end

function GuildLeagueOfLegendsModel:guild_add_evet()
    if (GuildModel.guildHave and ModuleUtil.hasModuleOpen(ModuleId.GuildLeague.id)) then
        self:getBaseInfo();
    end
end

function GuildLeagueOfLegendsModel:guild_exit_evet()
    self.isInMatch = false;
    Dispatcher.dispatchEvent("GLOL_MatchInfoUpdate");
    Dispatcher.dispatchEvent("GLOL_guessStatusUpdate");
    self:redCheck();
end

function GuildLeagueOfLegendsModel:Guild_GuildLeagueNotify(_, param)
    local noticeType = param.notifyType;
    if (noticeType == GameDef.GuildLeagueNotifyType.StateNotify) then
        local data = param.stateInfo;
        self.roundState = data.state;
        self.stateStamp = data.stateEndTimeMs;
        self:upBattleIndexData(self.matchRound, data.guessBattleInfo.battleIndex, data.guessBattleInfo);
        -- self:processGroupData(data.guessBattleInfo);
    elseif (noticeType == GameDef.GuildLeagueNotifyType.RoundNotify) then
        local data = param.roundInfo;
        if (data.round ~= self.matchRound) then
            -- print(2233, "=========== 进入下一赛程", data.round);
            local myGuess = self.myGuessInfo[self.matchRound];
            -- printTable(2233, "===== 要展示竞猜结果~~~~~", self.myGuessInfo, self.matchRound)--, result, data.guessBattleInfo);
            if (myGuess) then
                local result = myGuess.side == data.guessBattleInfo.winSide;
                ViewManager.open("GLLegendsGuessView", {showAnim = true});
                local round = self.matchRound
                Scheduler.scheduleNextFrame(function()
                    Dispatcher.dispatchEvent("GLOL_guessResult", round, result, data.guessBattleInfo);
                end)
            else
                ViewManager.close("GLLegendsGuessView");
            end
            self:getBaseInfo();
        end
        self:checkSelfGuildInMap();
        self.matchRound = data.round;
    elseif (noticeType == GameDef.GuildLeagueNotifyType.GuessNotify) then
        local data = param.battlePosInfo;
        local groupInfo = self.groupInfo[self.matchRound];
        for battleIndex, battleInfo in pairs(groupInfo) do
            if (battleInfo.isGuess) then
                for side, info in pairs(battleInfo.battlePosInfo) do
                    info.count = data[side].count
                end
                self.guessInfo = battleInfo;
                printTable(2233, "------------ 竞猜4", battleInfo);
                self:upGuessStatus(true);
            end
        end
    end
    Dispatcher.dispatchEvent("GLOL_MatchInfoUpdate");
    self:redCheck()
end

function GuildLeagueOfLegendsModel:getBaseInfo()
    self:initTeamInfo();
    if (self.matchRound == 0 or self.matchRound == 7) then
        self.guildMap = {}
        self.myGuessInfo = {}
        self.groupInfo = {}; -- 比赛分组信息 
        self.posInfo = {}; -- key为完整的位置key
    end
    RPCReq.Guild_GuildLeagueInfoReq({}, function (param)
        self.guildMap = param.guildBaseInfo or {};
        -- 
        local matchInfo = param.guildMgrInfo or {};
        self.matchRound = matchInfo.round or 0;
        self.roundState = matchInfo.state or 0;
        local roundList = matchInfo.battleGroupRoundList or {};
        self:processGroupData(roundList);
        self.myGuessInfo = param.myGuessInfo or {};
        self.stateStamp = param.stateEndTimeMs or 0;
        self.notEnoughGuild = matchInfo.isFail or false;
        self:checkSelfGuildInMap();
        Dispatcher.dispatchEvent("GLOL_MatchInfoUpdate");
        self:redCheck()
    end)
end

function GuildLeagueOfLegendsModel:processGroupData(groupInfoList)
    -- 整理数据方便查找
    for _, info in pairs(groupInfoList) do
        local round = info.round or self.matchRound;
        local list = info.enemyBattleList or {};
        if (not self.groupInfo[round]) then
            self.groupInfo[round] = {};
        end
        
        local groupInfo = self.groupInfo[round];
        for _, battleInfo in pairs(list) do
            groupInfo[battleInfo.battleIndex] = battleInfo;
            if (round == self.matchRound and battleInfo.isGuess) then
                self.guessInfo = battleInfo;
                print(2233, "---------------------- 竞猜1");
                self:upGuessStatus(true);
            end
        end
    end
    for round, groupInfo in pairs(self.groupInfo) do
        for battleIndex, battleInfo in pairs(groupInfo) do
            for _, info in pairs(battleInfo.battlePosInfo) do
                local side = info.side;
                local key = self:getPosKey(round, battleIndex, side);
                local arr = string.split(key, "_");
                local group = tonumber(arr[1]);
                local index = tonumber(arr[2]);
                local pos = tonumber(arr[3]);
                self.posInfo[key] = info;
                info.isWin = battleInfo.winSide and battleInfo.winSide == side or false;
                info.key = key;
                info.teamCount = (side == 1 and battleInfo.leftCount or battleInfo.rightCount) or 0;
                info.teamLose = (side == 1 and battleInfo.leftLoseCount or battleInfo.rightLoseCount) or 0;
                info.group = group;
                info.index = index;
                info.pos = pos;
                info.round = round;
                info.battleIndex = battleIndex;
                if (index == 1 and info.isWin) then -- 最顶部的公会数据
                    local key1 = group.."_0_1"
                    local info1 = clone(info);
                    self.posInfo[key1] = info1;
                    info1.round = round + 1
                    -- info1.battleIndex = 1;
                    info1.side = 1;
                end
            end
        end
    end
end

function GuildLeagueOfLegendsModel:checkSelfGuildInMap()
    local selfGuildId = GuildModel.guildHave and GuildModel.guildList.id or 0;
    local round = self.matchRound
    self.isInMatch = false;
    if (self.guildMap[selfGuildId]) then
        local list = self.groupInfo[round];
        if (list) then
            for _, battleInfo in pairs(list) do
                for _, guildInfo in pairs(battleInfo.battlePosInfo) do
                    if (guildInfo.guildId == selfGuildId) then
                        self.isInMatch = true;
                    end
                end
            end
        end
    end
end

function GuildLeagueOfLegendsModel:upBattleIndexData(round, battleIndex, data)
    -- body
    local battleInfo = self.groupInfo[round] and self.groupInfo[round][battleIndex] or false;
    if (battleInfo) then
        if (data.leftCount) then battleInfo.leftCount = data.leftCount end
        if (data.leftLoseCount) then battleInfo.leftLoseCount = data.leftLoseCount end
        if (data.rightCount) then battleInfo.rightCount = data.rightCount end
        if (data.rightLoseCount) then battleInfo.rightLoseCount = data.rightLoseCount end
        if (data.winSide) then battleInfo.winSide = data.winSide end
        for side, info in pairs(battleInfo.battlePosInfo) do
            info.count = data.battlePosInfo[side].count
            info.isWin = battleInfo.winSide and battleInfo.winSide == side or false;
            info.teamCount = (side == 1 and battleInfo.leftCount or battleInfo.rightCount) or 0;
            info.teamLose = (side == 1 and battleInfo.leftLoseCount or battleInfo.rightLoseCount) or 0;
            local key = self:getPosKey(round, battleIndex, side);
            self.posInfo[key] = info;
        end
        if (data.isGuess) then 
            self.guessInfo = battleInfo 
            print(2233, "---------------------- 竞猜2");
            self:upGuessStatus(true);
        end
    else
        self.groupInfo[round] = self.groupInfo[round] or {};
        self.groupInfo[round][battleIndex] = data;
    end
end

-- 获取位置上的玩家信息  pos参照posList
function GuildLeagueOfLegendsModel:getPosInfo(group, pos)
    local key = group.."_"..pos;
    return self.posInfo and self.posInfo[key] or false;
end

function GuildLeagueOfLegendsModel:getLineStatus(key, group)
    local arr = string.split(key, "_");
    local index = tonumber(arr[1])
    local pos = tonumber(arr[2])
    local preIndex = index + 1;
    local prePos2 = pos * 2;
    local prePos1 = pos * 2 - 1;
    local key1 = string.format("%s_%s_%s", group, preIndex, prePos1);
    local key2 = string.format("%s_%s_%s", group, preIndex, prePos2);
    local playerInfo1 = self.posInfo[key1];
    local playerInfo2 = self.posInfo[key2];
    local status = 0;
    local showSpine = false;
    if (playerInfo1 and playerInfo2 and not self.posInfo[group.."_"..key]) then
        showSpine = true;
    end
    if (playerInfo1 and playerInfo1.round and playerInfo1.round < self.matchRound and playerInfo1.isWin) then
        status = 1;
    elseif (playerInfo2 and playerInfo2.round and playerInfo2.round < self.matchRound and playerInfo2.isWin) then
        status = 2;
    end
    return status, showSpine
end

function GuildLeagueOfLegendsModel:getPosKey(round, battleIndex, side)
    local group = 0;
    local index = 0;
    local pos = 1;
    if (round == GameDef.GuildLeagueRound.One) then -- 64
        group = math.ceil(battleIndex / 4);
        index = 3;
        local x = battleIndex % 4;
        x = x == 0 and 4 or x;
        pos = (x - 1) * 2 + side;
    elseif (round == GameDef.GuildLeagueRound.Two) then -- 32
        group = math.ceil(battleIndex / 2);
        index = 2;
        local x = battleIndex % 2;
        x = x == 0 and 2 or x;
        pos = (x - 1) * 2 + side;
    elseif (round == GameDef.GuildLeagueRound.Three) then -- 16
        group = battleIndex;
        index = 1;
        pos = side;
    elseif (round == GameDef.GuildLeagueRound.Four) then -- 8
        index = 3;
        pos = side + ((battleIndex - 1) * 2);
    elseif (round == GameDef.GuildLeagueRound.Five) then -- 4
        index = 2;
        pos = side + ((battleIndex - 1) * 2);
    elseif (round == GameDef.GuildLeagueRound.Six) then -- 2
        index = 1;
        pos = side;
    end
    local key = group.."_"..index.."_"..pos;
    return key;
end

function GuildLeagueOfLegendsModel:getPosEmptyTitle(posKey)
    posKey = posKey or ""
    local arr = string.split(posKey, "_");
    local str = ""
    if (arr and next(arr)) then
        local group = tonumber(arr[1]);
        local index = tonumber(arr[2]);
        if (group ~= 0) then
            str = Desc["GLOL_group1"..index]
        else
            str = Desc["GLOL_group0"..index]
        end
    end
    return str;
end

function GuildLeagueOfLegendsModel:getGuildTeamInfo(guildId)
    RPCReq.Guild_GuildLeagueGetBattleArray({
        guildId = guildId,
    }, function(param)
        Dispatcher.dispatchEvent("GLOL_guildTeam", guildId, param);
    end)
end

-- 将工会阵容信息变成一条一条信息
function GuildLeagueOfLegendsModel:rebuildTeamInfo(teamInfo)
    teamInfo = teamInfo or {};
    local arr = {};
    for _, info in pairs(teamInfo) do
        for _, t in pairs(info.arrayList) do
            local d = {};
            d.combat = t.combat;
            d.heroInfos = t.heroInfos;
            d.playerId = info.playerId;
            d.name = info.name;
            d.level = info.level;
            d.head = info.head;
            d.sex = info.sex;
            d.serverId = info.serverId;
            d.headBorder = info.headBorder;
            table.insert(arr, d);
        end
    end
    table.sort(arr, function(a, b)
        return a.combat > b.combat
    end)
    return arr;
end

function GuildLeagueOfLegendsModel:upGuessStatus(showVirtual)
    self.guessState = 0;
    self.guessGroup = -1;
    if (self.guessInfo) then
        local round = self.matchRound;
        local key = self:getPosKey(round, self.guessInfo.battleIndex, 1);
        local group = tonumber(string.split(key, "_")[1]);
        self.guessGroup = group;
        if (self.roundState == GameDef.GuildLeagueState.Pre) then
            self.guessState = 1;
            if (self.myGuessInfo[self.matchRound]) then
                self.guessState = 2;
            end
        elseif (self.roundState == GameDef.GuildLeagueState.Lock) then
            ViewManager.close("GLLegendsBetView");
            self.guessState = 2;
        elseif (self.roundState == GameDef.GuildLeagueState.Fight) then
            self.guessState = 3;
            if (showVirtual) then
                print(2233, "========================================== 模拟战斗开始")
                self:virtualFight();
            end
        end
    end
    -- print(2233, "---------- 竞猜状态变更  回合阶段", self.roundState, "  竞猜状态 ",self.guessState)
    Dispatcher.dispatchEvent("GLOL_guessStatusUpdate")
    self:redCheck()
end

-- 模拟队伍逐渐减少
function GuildLeagueOfLegendsModel:virtualFight()
    for idx, handle in pairs(self.fightTimer) do
        if (handle) then
            Scheduler.unschedule(handle);
        end
        self.fightTimer[idx] = false;
    end
    local time = (self.stateStamp - ServerTimeModel:getServerTimeMS()) / 1000;
    for i = 1, 2 do
        local loss = 0;
        if (i == 1 and self.guessInfo.leftCount and self.guessInfo.leftLoseCount) then
            loss = self.guessInfo.leftLoseCount;
        elseif (self.guessInfo.rightCount and self.guessInfo.rightLoseCount) then
            loss = self.guessInfo.rightLoseCount;
        end
        local pre = loss > 0 and time / loss or 0
        local arr = {}
        print(2233, "======== 队伍"..i.."  损失"..loss);
        math.randomseed(self.stateStamp + pre * i + i)
        for m = 1, loss do
            local offset = 0;
            if (m == 1 and loss ~= 1) then
                offset = math.random() * pre / 2;
            elseif m == loss then
                offset = time - math.random() * pre / 3;
            else
                offset = (math.random() - 1.5 + m) * pre
            end
            table.insert(arr, offset)
        end
        printTable(2233, arr);
        local count = 1;
        local totalTime = 0;
        if (#arr > 0) then
            local timer = Scheduler.schedule(function(dt)
                totalTime = totalTime + dt;
                local t = arr[count];
                if (totalTime >= t) then
                    self.guessInfo.battlePosInfo[i].sub = count;
                    Dispatcher.dispatchEvent("GLOL_virtualFight"..i, count);
                    print(2233, "========================================== 模拟战斗"..i, count, totalTime);
                    count = count + 1;
                    if (count > loss) then
                        Scheduler.unschedule(self.fightTimer[i])
                        self.fightTimer[i] = false;
                    end
                end
            end, 0.1, 99999)
            self.fightTimer[i] = timer;
        end
    end

end

function GuildLeagueOfLegendsModel:guess(side, index)
    -- body
    local info = {
        battleIndex = self.guessInfo.battleIndex,
        guessGuildId = self.guessInfo.battlePosInfo[side].guildId,
        side = side,
    }
    if (index) then
        info.index = index;
    end
    RPCReq.Guild_GuildLeagueSupport(info, function(param)
        self.myGuessInfo = param.myGuessInfo;
        -- printTable(2233, "===== 自己竞猜了~~~~~", self.myGuessInfo);
        print(2233, "---------------------- 竞猜3");
        self:upGuessStatus();
    end)
end

function GuildLeagueOfLegendsModel:getBattleData(guildId, round)
    RPCReq.Guild_GuildLeagueGetVideoRecords({
        guildId = guildId
    }, function(param)
        local data = param.videoRecords and param.videoRecords[round] or false;
        local list = data and data.videoList or false
        Dispatcher.dispatchEvent("GLOL_guildBattleData", guildId, list);
    end)
end

function GuildLeagueOfLegendsModel:getTop8Guild()
    if (self.matchRound <= GameDef.GuildLeagueRound.Four) then
        return {};
    end
    local list = {};
    for _, guildInfo in pairs(self.guildMap) do
        if (guildInfo.round >= GameDef.GuildLeagueRound.Four) then
            if self.matchRound == GameDef.GuildLeagueRound.Seven then
                table.insert(list, guildInfo)
            elseif (guildInfo.round < self.matchRound) then
                table.insert(list, guildInfo)
            end
        end
    end
    TableUtil.sortByMap(list, {{key="round", asc = false}, {key="combat", asc = false}, {key="guildId", asc = false}})
    local arr = {}
    for i = 8, 1, -1 do
        if (list[1]) then
            arr[i] = list[1];
            table.remove(list, 1);
        end
    end
    return arr;
end

function GuildLeagueOfLegendsModel:isOutMatch(posKey)
    local arr = string.split(posKey, "_");
    local group = tonumber(arr[1]);
    local index = tonumber(arr[2]);
    local pos = tonumber(arr[3]);
    local guild = self.posInfo[posKey]
    local flag = not guild.isWin;
    local newkey = string.format("%s_%s_%s", group, index - 1, math.ceil(pos / 2));
    if (not self.posInfo[newkey]) then -- 下个位置没数据就是还没打 就没出局
        return false;
    else
        -- return not guild.isWin
        while(index >= 0) do
            index = index - 1
            local newkey1 = string.format("%s_%s_%s", group, index, math.ceil(pos / 2));
            pos = math.ceil(pos / 2)
            local guildInfo = self.posInfo[newkey1];
            if (guildInfo) then
                if (guildInfo.guildId == guild.guildId) then
                    flag = flag--guildInfo.isWin == false or flag;
                else
                    flag = true;
                end
            else
                break;
            end
        end
        return flag;
    end
end

function GuildLeagueOfLegendsModel:isGuildLegendsArrayType(arrayType)
    return arrayType == GameDef.BattleArrayType.GuildLeagueOne
            or arrayType == GameDef.BattleArrayType.GuildLeagueTwo
            or arrayType == GameDef.BattleArrayType.GuildLeagueThree
end

function GuildLeagueOfLegendsModel:getBattleTeamType()
    return {
        GameDef.BattleArrayType.GuildLeagueOne,
        GameDef.BattleArrayType.GuildLeagueTwo,
        GameDef.BattleArrayType.GuildLeagueThree
    }
end

-- ========================================================================================== 布阵处理

function GuildLeagueOfLegendsModel:initTeamInfo()
    self.allTeamInfo = {};
    self.heroInTeamMap = {};
    local defTypes = self:getBattleTeamType();
    for i, v in ipairs(defTypes) do
        local const = DynamicConfigData.t_GLConst[1];
        local requseInfo={
            fightId	= const.fightId,
            playerId= 0,
            gamePlay= v
        }
        self.allTeamInfo[v] = {
            arrayType = v,
            array={},
        }
        local teamIndex = i
        local function success(data)
            -- printTable(2233, "HigherPvPModel: initTeamInfo", data.array);
            if (data.array) then
                for uuid, d in pairs(data.array) do
                    local heroInfo = CardLibModel:getHeroByUid(d.uuid);
                    if (heroInfo) then
                        self.heroInTeamMap[heroInfo.code..""] = {
                            team = teamIndex,
                            uuid = heroInfo.uuid
                        }
                        self.allTeamInfo[v].array[uuid] = d;
                    end
                end
            end
        end
        RPCReq.Battle_GetOpponentBattleArray(requseInfo,success)
    end
end

function GuildLeagueOfLegendsModel:checkHeroInTeam(heroCode)
    local team = self:getTeamInfo();
    if (team[heroCode..""]) then
        return team[heroCode..""].team;
    end
    return false;
end

function GuildLeagueOfLegendsModel:getTeamInfo()
    return self.heroInTeamMap or {}
end

function GuildLeagueOfLegendsModel:getArrayByType(type)
    return self.allTeamInfo[type];
end

function GuildLeagueOfLegendsModel:saveTeamInfo(arrayType, cb)
    local typeArr = self:getBattleTeamType();
    local allArr = {}
    for _, v in ipairs(typeArr) do
        table.insert(allArr, self:getArrayByType(v));
    end

    local gamePlayType = GameDef.GamePlayType.GuildLeague;
    local info = {
        arrays = allArr,
        gamePlayType = gamePlayType
    }
    RPCReq.Battle_UpdateArrayMap(info, function (param)
        if (param) then
            for _, v in ipairs(typeArr) do
                BattleModel.__arrayInfos[v] = self:getArrayByType(v);
            end
            if (cb) then cb() end;
        end
    end)
end

function GuildLeagueOfLegendsModel:setHeroToTeam(seatId, heroInfo, oldHeroInfo)
    local team = self:getTeamInfo();
    local teamType = self:getBattleTeamType()[self.curTeamIdx];
    if (heroInfo) then
        team[heroInfo.code..""] = {
            team = self.curTeamIdx,
            uuid = heroInfo.uuid,
        }
        self.allTeamInfo[teamType].array[heroInfo.uuid] = {
            uuid = heroInfo.uuid,
            id = seatId,
        }
    end
    if (oldHeroInfo) then
        team[oldHeroInfo.code..""] = nil;
        self.allTeamInfo[teamType].array[oldHeroInfo.uuid] = nil;
    end
    self:checkTeamHasEmpty()
end

function GuildLeagueOfLegendsModel:checkTeamHasEmpty()
    local arrayType = self:getBattleTeamType();
    for type, data in pairs(self.allTeamInfo) do
        if (type == arrayType[1]) then
            RedManager.updateValue("GLOL_teamEmpty1", TableUtil.GetTableLen(data.array) < 1);
            -- printTable(2233, "HigherPvp_teamEmpty1", data.array, TableUtil.GetTableLen(data.array) < 1)
        elseif (type == arrayType[2]) then
            RedManager.updateValue("GLOL_teamEmpty2", TableUtil.GetTableLen(data.array) < 1);
            -- printTable(2233, "HigherPvp_teamEmpty2", data.array, TableUtil.GetTableLen(data.array) < 2)
        elseif (type == arrayType[3]) then
            RedManager.updateValue("GLOL_teamEmpty3", TableUtil.GetTableLen(data.array) < 1);
            -- printTable(2233, "HigherPvp_teamEmpty3", data.array, TableUtil.GetTableLen(data.array) < 3)
        end
    end
end

function GuildLeagueOfLegendsModel:checkHeroInTeamByUid(heroUuid)
    local team = self:getTeamInfo();
    for _, info in pairs(team) do
        if (info.uuid == heroUuid) then
            return info.team;
        end
    end
    return false;
end

function GuildLeagueOfLegendsModel:lottory(type)
    local info = {
        drawType = type
    }
    RPCReq.Guild_GuildLeagueDraw(info, function(param)
        
        Dispatcher.dispatchEvent("GuildLeagueOfLegendsModel_DrawSuc", param.drawIndexList, param.drawInfoList)
        -- param.drawInfoList
    end)
end

function GuildLeagueOfLegendsModel:getLuckList()
    RPCReq.Guild_GuildLeagueGetDrawRecords({}, function(param)
        Dispatcher.dispatchEvent("GuildLeagueOfLegendsModel_luckList", param.drawInfoList);
    end)
end

function GuildLeagueOfLegendsModel:exchangeCoin(num)
    RPCReq.Guild_GuildLeagueBuy({
        count = num
    })
end

-- 显示快捷入口
function GuildLeagueOfLegendsModel:canShowFastEnter()
    if (GuildModel.guildHave and self.fastEnter and next(self.guildMap) and self.matchRound > 0 and self.matchRound < 7) then
        return true;
    end
    return false;
end

-- 1\正处于比赛阶段时（进行中）,如果玩家可竞猜，但未竞猜，比赛界面的【竞猜】按钮有红点，直到使用了竞猜
-- 2\正处于比赛阶段时（进行中）,公会入口按钮，公会联赛建筑，传奇赛页签，前往参与按钮有红点
function GuildLeagueOfLegendsModel:redCheck()
    local guessRed = false;
    local enterRed = false;
    if (GuildModel.guildHave and next(self.guildMap) and self.matchRound > 0 and self.matchRound < 7) then
        -- 1
        if (self.roundState == GameDef.GuildLeagueState.Pre and not self.myGuessInfo[self.matchRound]) then
            guessRed = true;
        end
        -- 2
        enterRed = true;
    end
    RedManager.updateValue("V_GLOL_enter", enterRed);
    RedManager.updateValue("V_GLOL_guessRed", guessRed);
end

function GuildLeagueOfLegendsModel:reqGuildInfo(guildId, serverId)
    local info = {
        tarGuildId = guildId,
        tarServerId = serverId
    }
    RPCReq.Guild_FindGuildInfo(info, function(param)
        local data = param.data
        Dispatcher.dispatchEvent("GLOL_findGuildInfo", data);
    end)
end

return GuildLeagueOfLegendsModel
