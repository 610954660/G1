--Name : HandbookModel.lua
--Author : generated by FairyGUI
--Date : 2020-5-28
--Desc : 


local HandbookModel = class("HandbookModel", BaseModel)

function HandbookModel:ctor()
	
	self:initListeners()
	self.point = 0 			--	1:integer #收集点
	self.title  = 0			--	2:integer #称号
	self.heroOpertion  = 0			--	2:integer #主界面设置展示的模型id
	self.fashionCode = 0 --英雄显示的皮肤
	self.canGetWeekReward = 0 --		3:integer #当周有没有领取过奖励
	self.data = {}
	self.heroData = {}      --玩家得到过的英雄  heroid为key
	self.heroTabData = {}   --左侧标签英雄列表  titleId为key 的数组
	self.heroTabNum = {}    --各标签列表中玩家拥有的数量
	self.heroTabLevel = {}
	self.heroZan = {}  --英雄赞信息
	self.heroGroup = {} -- 英雄组合收集情况
	self.heroDataEx = {} --英雄数据，key为英雄id
	self.weekRewardFlag = false
	
	self.redMapInited = false --红点列表是否初始化了
	
	self.dataInited = false --初始数据是否拿到了
	
	self.firstRedHero = {}
	self.allGoodwiilLevel = 0 --总好感度等级
	self.allGoodwiilExp = 0 --总好感度经验
	self.maxNum     = DynamicConfigData.t_limit[GameDef.GamePlayType.HeroTotems].maxTimes
    self.limitNum   = 0
end

function HandbookModel:init()

end


--卡牌是否已经获取到的
function HandbookModel:loginPlayerDataFinish(data)

	self:GetAllHeroInfo(true)
end

function HandbookModel:updateWeekReward()
	local weekRewardFlag = self.weekRewardFlag
	if not weekRewardFlag then weekRewardFlag = 0 end
	local timeOnWeekBegin = TimeLib.GetDateStamp() + (7 - TimeLib.DayInWeek() + 1) * 24 * 60 * 60 * 1000
	self.canGetWeekReward = weekRewardFlag < timeOnWeekBegin and self.title >= 6
	RedManager.updateValue("V_HANDBOOK_WEEKREWARD", self.canGetWeekReward)
end


--获取全部英雄图鉴信息
function HandbookModel:GetAllHeroInfo(isInit)
	RPCReq.HeroTotems_GetAllHeroInfo({}, function(data)
			printTable(33,"HeroTotems_GetAllHeroInfo callback", data)
			self:HeroTotems_AllTotemsInfo(0,data, isInit)
	end)
end

--获取好感度等级
function HandbookModel:GetLinkingLevelById(id)
	local hcf = self.heroData[id]
	if hcf then
		return hcf.likingLevel
	end
	return 0
end
function HandbookModel:checkHeroLimitTime(heroCode)
	local hero = nil
	for key,group in pairs(DynamicConfigData.t_HeroTotems) do
		for k,v in pairs(group) do
			if v.hero == heroCode then
				hero = v
				break
			end
		end
	end
	if hero then
		local openSeverTime = ServerTimeModel:getOpenDateTime()
		local curSeverTime = ServerTimeModel:getServerTime()
		local dayNum = ServerTimeModel:getOpenDay() + 1
		local state = false
		if dayNum >= hero.date[1].start and (dayNum <= hero.date[1].endTime or hero.date[1].endTime == 0)then
			state = true
		end
		if hero.startDt ~= "" and hero.endDt ~= ""  and state then
			if curSeverTime >= DateUtil.getDateSecByStr(hero.startDt) and curSeverTime <= DateUtil.getDateSecByStr(hero.endDt) then
				state = true
			else
				state = false
			end
		end
		return state
	end
	return true
end
function HandbookModel:HeroTotems_AllTotemsInfo(_,data, isInit)
	self.data = data.data
	self.title = self.data.title and self.data.title or 0
	self.point = self.data.point and self.data.point or 0
	self.heroGroup = self.data.heroRecommendsetReward or {}
	self.allGoodwiilLevel = self.data.allGoodwill and self.data.allGoodwill.level or 1
	self.allGoodwiilExp = self.data.allGoodwill and self.data.allGoodwill.likingExp or 0
	self.dataInited = true
	local oldHeroOpertion = self.heroOpertion
	self.heroOpertion = self.data.heroOpertion and self.data.heroOpertion or false
	-- self:titleUpgradeRedCheck()
	if oldHeroOpertion ~= self.heroOpertion then
		Dispatcher.dispatchEvent(EventType.mainui_showHeroChange) --发个通知去更新主界面的立绘
	end
	local oldFashionCode = self.fashionCode
	self.fashionCode = self.data.fashionCode and self.data.fashionCode or false
	if oldFashionCode ~= self.fashionCode then
		Dispatcher.dispatchEvent(EventType.mainui_showHeroChange) --发个通知去更新主界面的立绘
	end
	self.weekRewardFlag = self.data.weekRewardFlag
	self:updateWeekReward()
	--这个时候红点值才有可能改true，所以这个时候才初始化
	if not self.redMapInited then
		self:initRedMap()
	end
	self:checkMemoiristRed()
	if self.data.race then
		for k,v in pairs(self.data.race) do
			for m,n in pairs(v.hero) do
				if not self.heroData[m] then
					if isInit ~= true then
						RedManager.updateValue("V_HANDBOOK_NEW_HERO"..m, true)
						if not self.firstRedHero[n.heroCode] then self.firstRedHero[n.heroCode] = n.heroCode end
					end
					self.heroData[m] = n
				end
				if not self.heroData[m].firstReward then 
					if not self.firstRedHero[n.heroCode] then self.firstRedHero[n.heroCode] = n.heroCode end
					RedManager.updateValue("V_HANDBOOK_NEW_HERO"..m, self:checkHeroLimitTime(n.heroCode))
				end
			end
			self.heroTabLevel[k] = v.level
		end
	end

	self.heroTabData = {}
	self.heroDataEx = {}
	for k,v in pairs(DynamicConfigData.t_HeroTotems) do
		local dd = {}
		local num = 0
		--local sindex = -1
		for m,n in pairs(v) do
			table.insert(dd,n )
			if self.heroData[n.hero] then
				num = num + 1
				--sindex = #dd
			end
			self.heroDataEx[n.hero] = n
		end
		--local ddnum = #dd
		--if ddnum > 7 then ddnum = 7 end
		--local midNum = math.ceil(ddnum/2.0) 
		--print(33,"midNum = ",#dd,midNum,self.heroData[dd[midNum].hero],sindex)
		--if not self.heroData[dd[midNum].hero] and sindex > -1 then
			--local temp = dd[midNum]
			--dd[midNum] = dd[sindex]
			--dd[sindex] = temp
		--end
		
		self.heroTabNum[k] = num
		table.insert(self.heroTabData,dd )
	end

	local function cmp(a,b)
		return a[1].titleId < b[1].titleId
	end
	table.sort(self.heroTabData,cmp)
	self:titleUpgradeRedCheck()
	self:setLimitNumRed()
end

--战力计算：基础属性 + 等级*成长*进阶系数
function HandbookModel:getCardAllAttrInfo(heroId,level,step)
	local newAttr={};
	local baseInfo=DynamicConfigData.t_hero[heroId];
	for key, value in pairs(CardLibModel.baseAttr) do
		newAttr[value]=(baseInfo[value])+ (baseInfo[CardLibModel.growthAttr[key]] ) *(baseInfo['stageRate'..step])*level
	end

	for k, v in pairs(newAttr) do
		newAttr[k]=math.floor(v);
	end

	return newAttr;
end


function HandbookModel:getHeroSupportInfo(heroId,fuc)
	--if self.heroZan[heroId] then
		--fuc(self.heroZan[heroId])
		--return
	--end
	RPCReq.HeroTotems_GetHeroSupportInfo({heroCode = heroId}, function(data)
		self.heroZan[data.data.heroCode] = data.data
		fuc(self.heroZan[data.data.heroCode])
	end)
end

--卡牌是否已经获取到的
function HandbookModel:isCardGot(id)
	if self.heroData[id] then return true end
	return false
end


--服务端推送更新点数
function HandbookModel:HeroTotems_UpdatePoint(_,params)
	self.point = params.point and params.point or 0 
	self.data.point = self.point
	self:titleUpgradeRedCheck()
	Dispatcher.dispatchEvent(EventType.handbook_pointChange)
	return false
end

function HandbookModel:HeroTotems_UpdateLiking(_,data )
	local hero = data.hero
	self.allGoodwiilLevel = data.allGoodwill and data.allGoodwill.level or 1
	self.allGoodwiilExp = data.allGoodwill and data.allGoodwill.likingExp or 0
	if hero and hero.heroCode then
		local data = json.decode(FileCacheManager.getStringForKey("Memoirist_List", "", nil, true))
		local heroMemoiristList = {}
		for _,v in ipairs(data) do
			heroMemoiristList[v.tipID] = v.showRed
		end
		local oldLevel = self.heroData[hero.heroCode].likingLevel or 1
		local nowLevel = hero.likingLevel or 1
		for i,v in pairs(DynamicConfigData.t_HeroStory) do
			if v.heroID == hero.heroCode then 
				if (oldLevel < v.unlock) and (nowLevel >= v.unlock) then 
					heroMemoiristList[v.tipID] = true
				end
			end
		end
		local info = {}
		for k,v in pairs(heroMemoiristList) do
			table.insert(info,{tipID = k, showRed = v})
		end
        FileCacheManager.setStringForKey("Memoirist_List",json.encode(info),nil,true)
		self.heroData[hero.heroCode] = hero
        self:checkMemoiristRed()
		Dispatcher.dispatchEvent(EventType.HeroDormitoryView_UpdateLiking)
	end
end

function HandbookModel:checkMemoiristRed()
	local redDot = false
	local data = json.decode(FileCacheManager.getStringForKey("Memoirist_List", "", nil, true))
	for _,v in ipairs(data) do
		if v.showRed then 
			redDot = true
			break
		end
	end
	RedManager.updateValue("V_HERO_DORMITORY_MEMOIRIST",redDot)
end

function HandbookModel:HeroTotems_UpdateHeroToems( _,data )
	self.heroTabLevel[data.category] = data.level
	Dispatcher.dispatchEvent(EventType.handbook_refresh_jihuo)
end
	
--设置主界面展示的英雄
function HandbookModel:setMainHero(heroId,itemUid,fashionId,successFunc)
	local params = {}
	params.heroCode = heroId
	params.itemUUid = itemUid 
	params.onSuccess = function (res )
		--printTable(1, res)
		ModelManager.HandbookModel.heroOpertion = heroId
		ModelManager.HandbookModel.fashionCode = fashionId or false
		if successFunc then 
			successFunc()
		end
		Dispatcher.dispatchEvent(EventType.mainui_showHeroChange)
	end
	RPCReq.HeroTotems_SetHeroHang(params, params.onSuccess)
end

function HandbookModel:titleUpgradeRedCheck()
	local carUpgrade = false
	local openId = ModelManager.HandbookModel.title
	local configInfos = DynamicConfigData.t_HeroTotemsTitleLevel[openId + 1]
	if configInfos then
		carUpgrade = ModelManager.HandbookModel.point >= configInfos.needPoint
	end
	RedManager.updateValue("V_HANDBOOK_UPGRADE", carUpgrade)

	-- 推荐组合
	local conf = DynamicConfigData.t_Recommendset
	for _, c in pairs(conf) do
		local flag = false;
		if (c.type == 1) then
			if (not self:isGotGroupReward(c.id) and self:isFinishConnect(c.hero1)) then
				flag = true;
			end
		end
		RedManager.updateValue("V_HELP_GROUP"..c.id, flag);
	end
end


function HandbookModel:initRedMap()
	for category = 1,5,1 do
		local categoryHeros = DynamicConfigData.t_HeroTotems[category]
		local redMap = {}
		for _,v in pairs(categoryHeros) do
			table.insert(redMap, "V_HANDBOOK_NEW_HERO"..v.hero)
		end
		RedManager.addMap("V_HANDBOOK_NEW_CATEGORY"..category, redMap)
	end

	-- 推荐组合
	local conf = DynamicConfigData.t_Recommendset
	local map = {};
	for _, c in pairs(conf) do
		if (c.type == 1) then
			table.insert(map, "V_HELP_GROUP"..c.id);
		end
	end
	RedManager.addMap("V_HELP_GROUP", map)
end

-- 是否已经领取过奖励
function HandbookModel:isGotGroupReward(id)
	for _, val in ipairs(self.heroGroup) do
		if (val == id) then
			return true;
		end
	end
	return false;
end

function HandbookModel:isFinishConnect(heroGroup)
	for _, info in pairs(heroGroup) do
		local id = info.heroCode;
		if (not self:isCardGot(id)) then
			return false;
		end
	end
	return true;
end

-- 领取推荐组合集齐奖励
function HandbookModel:getGroupConnectReward(id)
	RPCReq.HeroTotems_GiftHeroRecommendset({id = id}, function (param)
		table.insert(self.heroGroup, id);
		RedManager.updateValue("V_HELP_GROUP"..id, false);
		Dispatcher.dispatchEvent(EventType.handbook_groupaward)
	end)
end

function HandbookModel:initLimit(limit)
	if limit and limit.daily then
		local data = limit.daily[GameDef.GamePlayType.HeroTotems]
		if data then
			self.limitNum = data.times
		end
	end
end

function HandbookModel:addLimitNum(val)
	self.limitNum = self.limitNum + val
	self:setLimitNumRed()
	Dispatcher.dispatchEvent("HeroDormitoryView_Num")
end
function HandbookModel:setLimitNum(num)
	self.limitNum = num
	self:setLimitNumRed()
	Dispatcher.dispatchEvent("HeroDormitoryView_Num")
end

function HandbookModel:getResidueNum()
	local residue = self.maxNum - self.limitNum
	if residue < 0 then
		residue = 0
	end
	return residue
end

function HandbookModel:getHeroDataEx(heroId)
	return self.heroDataEx[heroId]
end

function HandbookModel:setLimitNumRed()
	local residueNum = self.maxNum - self.limitNum
	RedManager.updateValue("V_HERO_DORMITORY_INTERACT",residueNum > 0)
end

return HandbookModel
